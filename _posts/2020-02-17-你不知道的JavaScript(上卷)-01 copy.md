---
layout:     post
title:      你不知道的JavaScript(上卷)-笔记01
subtitle:   作用域是什么
date:       2020-02-17
author:     CHM
header-img: img/home-bg-o.jpg
catalog: true
tags:
    - JS
    - 你不知道的JavaScript
---


## 前言
你不知道的JavaScript[上卷]主要分为两部分。第一部分是:作用域与闭包；第二部分是:this与对象原型。这里主要讲的是第一部分的第一章。**作用域是什么**。

## 作用域
首先，一个编程语言，都有变量这个基本元素，用来存储数据，并且可以通过修改变量。通常是通过状态来记录变量的变化。那么，不同状态的变量都存储到哪里呢？我们就需要对变量的存储制定一个规则。在js中，这个规则就是作用域。

## 编译的原理
尽管通常将 JavaScript 归类为“动态”或“解释执行”语言，但事实上它是一门编译语言。
动态编程语言MDN是这样解释的:动态编程语言是指可在运行阶段时执行那些在编译阶段执行的操作的编程语言。比如，在 JavaScript 中， 我们可以在程序运行时改变变量的类型，或者为一个对象增加一个新属性或者方法。

js与传统的编译语言不同的是，它不是提前编译。编译结果也不能在发布式系统中进行移植。
传统的编译语言流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为编译。
1.分词/词法分析:此过程会将由字符组成的字符串分解成有意义的代码块（词法单元 token），空格是否会被当成词法单元，取决于空格在这门语言中是否具有意义。
```
eg: var a = 2;  
// 这段程序通常会被分解成为下面这些词法单元  
var、a、=、2、;
```
2.解析/语法分析:这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（AST）。
var a = 2; 的抽象语法树中可能会有一个叫作 VariableDeclaration 的顶级节点。接下来是一个叫作 Identifier（它的值是 a）的子节点，以及一个叫作 AssignmentExpression的子节点。AssignmentExpression 节点有一个叫作 NumericLiteral（它的值是 2）的子节点。

3.代码生成
将AST转换为可执行代码的过程被称为代码生成。
简单来说就是有某种方法可以将var a = 2; 的AST转化为一组机器指令，用来创建一个叫作a的变量（包括分配内存等），并将一个值存储在a中。

比起那些编译过程只有三个步骤的语言的编译器，JavaScript 引擎要复杂得多。
首先，JavaScript引擎不会有大量的时间来进行优化，因为与其他语言不同，JavaScript的编译过程不是发生在构建之前的。

对于JavaScript来说，大部分情况下编译发生在代码执行前的几微秒的时间内。在我们所要讨论的作用域背后，JavaScript引擎用尽了各种办法来保证性能最佳。

简单地说，任何JavaScript代码片段在执行前都要进行编译。因此，JavaScript编译器首先会对 var a = 2; 这段程序进行编译，然后做好执行它的准备，并且通常马上就会执行它。

## 理解作用域
引擎
>从头到尾负责整个JavaScript程序的编译及执行过程。

编译器
>引擎的好友之一，负责语法分析及代码生成等脏活累活。

作用域
>引擎的另一位好友，负责收集和维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符对访问权限。

变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在当前作用域查找该变量，如果能够找到就会对它赋值。

### 编译器
编译器生成代码，引擎执行它时，会通过查找a来判断它是否已声明过。查找的过程由作用域进行协助，但是引擎怎么查找会影响最终的查找结果。

在我们的例子中，引擎会为变量a进行LHS（左侧）查询，另一种查找类型叫作RHS（右侧）。
什么东西的左侧和右侧？是一个赋值操作的左侧和右侧。
RHS 查询与简单的查找某个变量的值别无二致,而LHS查询则是试图找到变量的容器本身，从而可以对其赋值。从这个角度说，RHS并不是真正意义上对“赋值操作对右侧”,更准备地说是“非左侧”。
你可以将 RHS 理解成 retrieve his source value（取到它的源值），这意味着“得到某某的值”。

你可能会倾向于将函数声明 function foo(a) {... 概念化为普通的变量声明
和赋值，比如 var foo、foo ＝ function(a) {...。如果这样理解的话，这
个函数声明将需要进行 LHS 查询。
然而还有一个重要的细微差别，编译器可以在代码生成的同时处理声明和值
的定义，比如在引擎执行代码时，并不会有线程专门用来将一个函数值“分
配给”foo。**因此，将函数声明理解成前面讨论的 LHS 查询和赋值的形式并不合适。**

### 引擎和作用域对对话
```
function foo(a) {
console.log( a ); // 2
}
foo( 2 );
```
        让我们把上面这段代码的处理过程想象成一段对话，这段对话可能是下面这样的。

        引擎：我说作用域，我需要为 foo 进行 RHS 引用。你见过它吗？
        作用域：别说，我还真见过，编译器那小子刚刚声明了它。它是一个函数，给你。
        引擎：哥们太够意思了！好吧，我来执行一下 foo。
        引擎：作用域，还有个事儿。我需要为 a 进行 LHS 引用，这个你见过吗？
        作用域：这个也见过，编译器最近把它声名为 foo 的一个形式参数了，拿去吧。
        引擎：大恩不言谢，你总是这么棒。现在我要把 2 赋值给 a。
        引擎：哥们，不好意思又来打扰你。我要为 console 进行 RHS 引用，你见过它吗？
        作用域：咱俩谁跟谁啊，再说我就是干这个。这个我也有，console 是个内置对象。
        给你。
        引擎：么么哒。我得看看这里面是不是有 log(..)。太好了，找到了，是一个函数。
        引擎：哥们，能帮我再找一下对 a 的 RHS 引用吗？虽然我记得它，但想再确认一次。
        作用域：放心吧，这个变量没有变动过，拿走，不谢。
        引擎：真棒。我来把 a 的值，也就是 2，传递进 log(..)。

### 小测试
检验一下到目前的理解程度。把自己当作引擎，并同作用域进行一次“对话”：
```
function foo(a) {
var b = a;
return a + b;
}
var c = foo( 2 );
```
1. 找到其中所有的 LHS 查询。（这里有 3 处！）
2. 找到其中所有的 RHS 查询。（这里有 4 处！）

## 作用域嵌套
我们说过，作用域是根据名称查找变量的一套规则。实际情况中，通常需要同时顾及几个
作用域。

当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用
域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，
或抵达最外层的作用域（也就是全局作用域）为止。

## 异常
为什么区分LHS和RHS是一件重要的事情？
考虑如下代码:
```
function foo(a) {
console.log( a + b );
b = a;
}
foo( 2 );
```
第一次对b进行RHS查询时是无法找到该变量对，也就是说，这是一个“未声明”的变量，因为在任何相关的作用域中都无法找到它。

如果RHS查询在所有嵌套作用域中遍寻不到所需的变量，引擎就会抛出ReferenceError异常。值得注意的是，ReferenceError是非常重要的异常类型。

相比之下，当引擎在执行LHS查询时，如果在顶层（全局作用域）中也找不到目标变量，全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非“严格模式”下。

接下来，如果RHS查询找到了变量，但是你尝试对这个变量进行不合理的操作，比如试图对一个非函数类型的值进行函数调用，那么引擎会抛出另一种类型的异常，叫作TypeError。

**ReferenceError同作用域判别失败相关,而TypeError则代表作用域判别成功了，但是对结果的操作是非法或不合理的。**

## 小结
作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对变量进行赋值，那么就是用LHS查询；如果目的是获取变量对值，就会使用RHS查询。操作法会导致LHS查询。＝操作符或调用函数时传入参数的操作都会导致关联作用域
的赋值操作。

JavaScript引擎首先会在代码执行前进行编译，在这个过程中，像var a = 2;这样对声明会被分解成两个独立对步骤：
1. 首先，var a 在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。
2. 接下来，a = 2 会查询（LHS查询）变量a并对其进行赋值。

LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所
需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层
楼），最后抵达全局作用域（顶层），无论找到或没找到都将停止。

不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式
地创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛
出 ReferenceError 异常（严格模式下）。

### 参考 
- [你不知道的JavaScript[上卷]](https://kingyinliang.github.io/PDF/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%EF%BC%88%E4%B8%8A%E5%8D%B7%EF%BC%89.pdf)
