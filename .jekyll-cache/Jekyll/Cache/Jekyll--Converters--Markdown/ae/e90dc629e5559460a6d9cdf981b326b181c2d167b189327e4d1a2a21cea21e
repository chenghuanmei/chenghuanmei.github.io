I"R<h2 id="前言">前言</h2>
<p>你不知道的JavaScript[上卷]主要分为两部分。第一部分是:作用域与闭包；第二部分是:this与对象原型。这里主要讲的是第一部分的第四章。<strong>提升</strong>。</p>

<h2 id="先有鸡还是先有蛋">先有鸡还是先有蛋</h2>
<p>直觉上会认为JavaScript代码在执行时是由上到下一行一行执行的。但实际上这并不完全正确，有一种特殊情况会导致这个假设是错误但。</p>

<p>考虑以下代码：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a = 2;
var a;
console.log(a)
</code></pre></div></div>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>console.log(a);
var a = 2
</code></pre></div></div>
<p>第一段代码结果是2，第二段代码结果是undefeated。</p>

<blockquote>
  <p>到底是声明（蛋）在前，还是赋值（鸡）在前?</p>
</blockquote>

<h2 id="编译器再度来袭">编译器再度来袭</h2>
<p>回顾第一章中关于编译器但内容。 引擎会在解释JavaScript代码之前首先对其进行编译。编译阶段中第一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来。第二章中展示了这个机制，也正是词法作用域的核心内容。</p>

<p>因此，正确的思考思路是，包括变量和函数声明在内的所有的声明都会在执行前首先被处理。</p>

<p>当你看到 var a = 2; 时，可能会认为这是一个声明。但JavaScript实际上会将其看成两个声明:var a; a = 2;。第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在原地等待执行阶段。</p>

<p>因此，打个比方，这个过程就好像变量和函数声明从它们在代码中出现的位置被“移动” 到了最上面。这个过程就叫作提升。</p>

<p>换句话说，先有蛋(声明)后有鸡(赋值)。</p>
<blockquote>
  <p>每个作用域都会进行提升操作。</p>
</blockquote>

<p>函数声明会被提升，但是函数表达式却不会被提升。</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>foo() // 不是ReferenceError ， 而是TypeError！
var foo = function bar() {
    // ...
}
</code></pre></div></div>
<p>这段程序中的变量标识符 foo() 被提升并分配给所在作用域(在这里是全局作用域)，因此 foo() 不会导致 ReferenceError。但是 foo 此时并没有赋值(如果它是一个函数声明而不 是函数表达式，那么就会赋值)。foo() 由于对 undefined 值进行函数调用而导致非法操作， 因此抛出 TypeError 异常。</p>

<h2 id="函数优先">函数优先</h2>
<p>函数声明和变量声明都会被提升。但是一个值得注意的一节（这个细节可以出现有多个”重复”声明的代码中）是函数会首先被提升，然后才是变量。</p>

<p>考虑以下代码:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>foo();
var foo;
function foo(){
    console.log(1);
}
foo = function(){
    console.log(2)
}
</code></pre></div></div>
<p>会输出 1 而不是 2 !这个代码片段会被引擎理解为如下形式:</p>

<p>function foo(){
    console.log(1)
}</p>

<p>foo()</p>

<p>foo = function(){
    console.log(2)
}</p>

<p>注意，var foo 尽管出现在 function foo()… 的声明之前，但它是重复的声明（因此被忽略了），因为函数声明会被提升到普通变量之前。</p>

<p>尽管重复的 var 声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>foo(); // 3
function foo() { 
    console.log( 1 );
}
var foo = function() { 
    console.log( 2 );
};
function foo() { 
    console.log( 3 );
}
</code></pre></div></div>

<p>虽然这些听起来都是些无用的学院理论，但是它说明了在同一个作用域中进行重复定义是 非常糟糕的，而且经常会导致各种奇怪的问题。
一个普通块内部的函数声明通常会被提升到所在作用域的顶部，这个过程不会像下面的代 码暗示的那样可以被条件判断所控制:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>foo(); // "b"
var a = true; 
if (a) {
    function foo() { console.log("a"); } 
} else {
    function foo() { console.log("b"); }
}
</code></pre></div></div>
<p>但是需要注意这个行为并不可靠，在 JavaScript 未来的版本中有可能发生改变，因此应该 尽可能避免在块内部声明函数。</p>

<h2 id="小结">小结</h2>
<p>我们习惯将 var a = 2;当作是一个声明，而实际上JavaScript引擎并不这么认为。它将var a; 和a = 2;当作是两个独立的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。</p>

<p>这意味着无论声明在作用域中的什么位置，都将在代码本身被执行前首先进行处理。可以将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的最顶端，这个过程被称为提升。</p>

<p>声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。</p>

<p>要注意避免重复声明，特别是当普通的 var 声明和函数声明混合在一起的时候，否则会引
起很多危险的问题!</p>

<h3 id="参考">参考</h3>
<ul>
  <li><a href="https://kingyinliang.github.io/PDF/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%EF%BC%88%E4%B8%8A%E5%8D%B7%EF%BC%89.pdf">你不知道的JavaScript[上卷]</a></li>
</ul>
:ET